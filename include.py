#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Jakub Staroń, 2016

import argparse
import os
import codecs
import re
import regex
from collections import deque


def directory_of_file(filename):
    return os.path.dirname(os.path.realpath(filename))


def load_lines(filename):
    with codecs.open(filename, "r", "utf-8") as file:
        lines = [line for line in file]
        return lines

def is_pragma(line):
    return re.match("^#pragma\s+once", line) is not None

def is_local_input(line):
    return re.match("^#include\s+\"(.*)\"", line) is not None

class FileIncluder:
    def __init__(self, path):
        self.path = path
        self.loaded = set()

    def load(self, line):
        include = self.get_include_name(line)
        if include not in self.loaded:
            self.loaded.add(include)
            return load_lines(os.path.join(self.path, include))
        else:
            return list()

    def get_include_name(self, line):
        match = re.match("^#include\s+\"(.*)\"", line)
        return match.group(1)


def copyright_message():
    message = (
        u'// Generated by include.py\n'
        u'// Jakub Staroń, 2016\n'
        u'// For more info see https://github.com/staronj/ProgrammingContestsLibrary\n'
    )
    return message

def main():
    parser = argparse.ArgumentParser(description='Generate random passwords.')
    parser.add_argument('--input', required=True, type=str,
                        help='name of input file')

    parser.add_argument('--output', required=True, type=str,
                        help='name of output file, must be different from input')

    parser.add_argument('--path', required=False, type=str,
                        help='path with PCL library, default is input file folder')

    parser.add_argument('--remove-comments', required=False, default=False, action='store_true',
                        help='if set, comments will be removed')

    parser.add_argument('--remove-whitespaces', required=False, default=False, action='store_true',
                        help='if set, unnecessary whitespaces will be removed, implies remove-comments')

    args = parser.parse_args()
    if args.path is None:
        args.path = directory_of_file(args.input)

    if args.input == args.output:
        parser.print_help()
        exit(1)

    if args.remove_whitespaces:
        args.remove_comments = True

    queue = deque()
    queue.extend(load_lines(args.input))

    includer = FileIncluder(args.path)
    code = ""

    while queue:
        line = queue.popleft()
        if is_pragma(line):
            continue
        elif is_local_input(line):
            lines = includer.load(line)
            queue.extendleft(reversed(lines))
        else:
            code += line

    not_inside_string = r'(?<=^(?!#)[^"\n]*?(?:(?:\"(?:\\"|[^\n"])*\")[^"\n]*?)*?)'

    if args.remove_comments:
        # Single line comments
        code = regex.subn(not_inside_string + r'\/\/[^\n]*$', r'', code, flags=re.MULTILINE)[0]

        # Multiline comments
        code = regex.subn(not_inside_string + r'\/\*(?:.|\n)*?\*\/', r'', code, flags=re.MULTILINE)[0]

    if args.remove_whitespaces:
        # Unnecessary white characters
        code = regex.subn(not_inside_string + r'\n\s+', r'\n', code, flags=re.MULTILINE)[0]
        code = regex.subn(not_inside_string + r'\s+\n', r'\n', code, flags=re.MULTILINE)[0]
        code = regex.subn(not_inside_string + r'\s\s+', r' ', code)[0]
        code = regex.subn(not_inside_string + r'(?P<char>\W)\s+(?!#)', r'\g<char>', code, flags=re.MULTILINE)[0]
        code = regex.subn(not_inside_string + r'\s+(?!#)(?P<char>\W)', r'\g<char>', code, flags=re.MULTILINE)[0]

    with codecs.open(args.output, "w", "utf-8") as file:
        file.write(copyright_message())
        file.write(code)


if __name__ == "__main__":
    main()
